# 객체지향 프로그래밍

- 정보(변수)와 행동(함수)을 묶어둔 것

- 추상화 : 복잡한 것은 숨기고, 필요한 것을 들어내는 것

- class(틀) , person(객체)

- 장점
  
  - 누군가는 로그인관련 / 누구는 게시판관련 업무.. 클래스 단위로 모듈화.
  
  - 필요한 부분만 수정하기 쉽기 때문에 프로그램의 유지보수가 쉽다

- 단점
  
  - 설계 시 많은 노력과 시간이 필요함
    
    - 다양한 객체들의 상호 작용 구조를 만들기 위해 많은 시간과 노력이 필요
  
  - 실행 속도가 상대적으로 느림
    
    - 절차 지향 프로그래밍이 컴퓨터의 처리구조와 비슷해서 실행 속도가 빠름

## 객체

- 컴퓨터 과학이라고도 불림

- 컴퓨터 과학에서 객체 또는 object는 클래스에서 정의한 것을 토대로 메모리(실제 저장공간)에 할당된 것으로 프로그램에서 사용되는 데이터 또는 식별자에 의해 참조되는 공간을 의미하며, 변수, 자료구조, 함수 또는 메서드가 될 수 있다.

- 쉽게 말해, 객체는 속성과 행동으로 구성된 모든 것

- 객체 = 세상에 존재하는 모든 것

- 디지털 세계(컴퓨터)로 넘어갈때, 이걸 어떻게 표현할 것인가?

- 이름.나이.신체.직책... 으로 추상화 class는 공통적으로 알고 있는 정보/ 인스턴스는 그 각각의 추상화

ex)

- 인간의 속성(정보)
  
  - 나이 :
  
  - 직업 : 
  
  - 행동(함수-메서드)

## 객체와 인스턴스

- 클래스로 만든 객체를 인스턴스 라고도 함
  
  - 객체와 인스턴스의 차이점?
  
  - 김종혁은 객체다(O), 김종혁은 인스턴스다(X), 이찬혁은 가수의 인스턴스다(O)

- 클래스를 만든다 == 타입을 만든다

# 파이썬은 모든 것이 객체

# 모든것에는 행동과 속성이 존재

ex) [3,2,1].sort() / 리스트.정렬() / 객체(data).행동()

ex)"banana".upper() / 문자열.대문자로() / 객체.행동()

- [1,2,3], [1],[],['hi]
  
  - 전부 리스트의 객체(인스턴스)

- "",'hi','파이썬'
  
  - 모두 문자열의 객체

- 객체(object)는 특정 타입의 인스턴스이다.
  
  - 123,900,5는 int의 인스턴스
  
  - 'hello','bye'는 모두 string의 인스턴스
  
  - [232,89,1],[]은 모두 list 타입의 인스턴스

- 객체(object)의 특징
  
  - 타입(type) : 어떤 연산자(operator)와 조작이 가능한가?
  
  - 속성(attribute) : 어떤 상태(데이터)를 가지는가?
  
  - 조작법(method) : 어떤 행위(함수)를 할 수 있는가?

- python의 객체와 클래스
  
  - 객체 = 속성 + 기능

## 클래스의 정의

- 클래스 정의
  
  - Class M(보통 대문자)yClass:     
  - upper, camel, pascal case

- 인스턴스 생성
  
  - my_instance = Myclass()

- 메서드 호출
  
  - my_instance.my_method()

- 속성
  
  - my_instance.my_attribute

## 클래스와 인스턴스

- 객체의 설계도(클래스)를 가지고, 객체(인스턴스)를 생성한다.

- 예시
  
  - person(클래스)안에 가수 이지은(인스턴스), 감독 강해피(인스턴스), 팬 김싸피(인스턴스)

- 파이썬은 모든 것이 객체, 모든 객체는 인스턴스

## 객체 비교하기

- ==
  
  - 동등한(equal)
  
  - 변수가 참조하는 객체가 동등한(내용이 같은)경우 True
  
  - 두 객체가 같아 보이지만 실제로 동일한 대상을 가리키고 있다고 확인해준 것은 아님

- is
  
  - 동일한(identical)
  
  - 두 변수가 동일한 객체를 가리키는 경우 True
  
  - 주소까지 같은 것

## 속성(데이터, 정보, 상태) -> 변수를 의미

- 특정 데이터 타입/ 클래스의 객체들이 가지게 될 상태/데이터를 의미

- 정보 = 클래스 변수 / 인스턴스 변수가 존재

- 클래스 변수 = 어디서 묻든 똑같은 변수

- 데이터 저장하는 변수!!!

- 공용으로 쓰이는 것 / 개인으로 쓰이는 것

- self를 통해서 변수를 찍는다! => 인스턴스 변수

- 변수만 찍는다! => 클래스 변수

## 인스턴스 변수

- 인스턴스 변수란?
  
  - 인스턴스가 개인적으로 가지고 있는 속성(attribute)
  
  - 각 인스턴스들의 고유한 변수
  
  - 개인에 따라 달라지는 것은 인스턴스

- 생성자 메서드(--init--)에서 sefl.<name>으로 정의

- 인스턴스가 생성된 이후 <instance>.<name>으로 접근 및 할당

- 인스턴스.변수명 = 값

- 변수 접근과 할당은 다름!!!

- john.age = 20 로만 해놓으면 john에만 할당되고, jh = person('jh')에는 jh의 age가 없음

- 개인이기 때문

## 클래스 변수

- 클래스 선언 내부에서 정의

- <classname>.<name>으로 접근 및 할당

- 공용으로 모두가 똑같이 대답하는 것!!!!!

- 인스턴스.클래스변수 가능함

# 공통으로 쓰는 공간 / 개인용 정의 공간

## 클래스 변수 활용(사용자 수 계산하기)

- 사용자가 몇 명인지 확인하고 싶다면?

```python
class Person:
    count = 0
    def __init__(self,name):
        self.name = name
        Person.count += 1
person1 = Person('김종혁')
person2 = Person('박효신')


```

## 클래스 변수와 인스턴스 변수

- 클래스 변수를 변경할 때는 항상 클래스.클래스변수 형식으로 변경

- **문법은 print(ci.pi)로 인스턴스 변수를 가져오는 문법인데 없으면 자동으로 클래스 변수를 찾아옴**

- 지역변수 없으면 글로벌 변수 가져오는 것과 같음

# OOP 메서드

## 메서드

- 특정 데이터 타입/클래스의 객체에 공통적으로 적용 가능한 행위(함수)

```python
class Person:
    def talk(self):
        print('h')
    def eat(sefl, food):
        print(f'{food} good')
```

## 메서드 종류

- 인스턴스 메서드 -> 인스턴스 변수를 처리

- 클래스 메서드 -> 클래스를 처리

- 정적 메서드 -> 나머지

## 인스턴스 메서드

- 인스턴스 변수를 사용하거나, 인스턴스 변수에 값을 생성하는 메서드

- 클래스 내부에 정의되는 메서드의 기본

- 호출시 첫번째 인자로 인스턴스 자기자신(self)이 전달됨

```python
class Myclass:
    def instance_method(self, arg1,):


my_instance = Myclass()
my_instance.instance_method(...)
```

- self가 들어가있으면 인스턴스 메서드라고 생각하기

## self

- 인스턴스 자기자신

- 파이썬에서 인스턴스 메서드는 호출 시 첫번째 인자로 인스턴스 자신이 전달되게 설계

## 생성자(constructor)메서드

- 인스턴스 객체가 생서오딜 때 자동으로 호출되는 메서드

- 인스턴스 변수들의 초기값을 설정
  
  - 인스턴스 생성
  
  - init 메서드 자동 호출

## 매직 메서드

- Double underscore(____)가 있는 메서드는 특수한 동작을 위해 만들어진 메서드

- 스페셜메서드 or 매직 메서드로 불림

- 특정 상황에 자동으로 불리는 메서드

## 예시

- 객체의 특수 조작 행위를 지정(함수, 연산사 등)
  
  - str : 해당 객체의 출력 형태를 지정
    
    - 프린트 함수를 호출할 때, 자동으로 호출
    
    - 어떤 인스턴스를 출력하면 str의 return 값이 출력
  
  - gt  : 부등호 연산자(>, greater than)

## 소멸자 메서드

- 인스턴스 객체가 소멸(파괴)되기 직전에 호출되는 메서드

## 클래스 메서드

- 클래스가 사용할 메서드

- @classmethod 데코레이터를 사용하여 정의

- 호출시, 첫번째 인자로 클래스(cls)가 전달됨

## 데코레이터

- 함수를 어떤 함수로 꾸며서 새로운 기능을 부여

- @데코레이터(함수명)형태로 위에 작성

## 클래스 메서드와 인스턴스 메서드

- 클래스 메서드 -> 클래스 변수 사용(cls)

- 인스턴스 메서드 -> 인스턴스 변수 사용(self)

- 그렇다면 인스턴스 변수, 클래스 변수 모두 사용하고 싶다면?
  
  - 클래스는 인스턴스 변수 사용이 불가능
  
  - 인스턴스 메서드는 클래스 변수, 인스턴스 변수 둘 다 사용 가능

## 스태틱 메서드

- 인스턴스 변수, 클래스 변수를 전혀 다루지 않는 메서드

- 언제? 속성을 다루지 않고 단지 기능(행동)만을 하는 메서드를 정의할 때 사용

- @staticmethod 데코레이터를 사용하여 정의

- 일반 함수처럼 동작하지만, 클래스의 이름공간에 귀속
  
  - 주로 해당 클래스로 한정하는 용도로 사용
  
  - no cls, no self

## 인스턴스와 클래스 간의 이름공간

- 클래스를 정의하면 클래스와 해당하는 이름 공간이 만들어짐

- 인스턴스를 만들면 인스턴스 객체가 생서오디고 이름 공간이 만들어짐

- 인스턴스에서 특정 속성에 접속하면

```python
__(던더)__
```

## 다중상속에서 부모클래스에서 다중으로 받은 변수는 앞에 있는 것부터 인식

- mro 메서드(Method Resolution Order)
  
  - 해당 인스턴스의 클래스가 어떤 부모 클래스를 가지는지 확인하는 메서드
  
  - 인스턴스.mro()
  
  - 기존인스턴스 -> 클래스 순으로 이름 공간 탐색할 때 상속 관계에 있다면, 인스턴스, 자식 클래스, 부모클래스로 확장

## 다형성

- 동일한 메시지에 대해 다른 방식으로 응답 가능

## 매서드 오버라이딩

## getter메서드와 setter메서드

- getter는 조회 setter는 변경

# 추상화, 상속, 다형성, 캡슐화

- 복잡한거 숨기고 필요한거 드러내기

- 부모클래스, 자식클래스 관계 / 재사용성 up

- 이름은 같은데, 동작은 다른 것 "오버라이딩", 자식이 변경

- 민감한 정보를 숨기는 것

- @property(getter) , 변수.setter
